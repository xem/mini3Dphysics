<title>Ch.14: Contraint Solving</title>
<h1>Chapter 14: Contraint Solving</h1>
<p>→ Source code: <a href="../lib/rigidbody.js">rigidbody.js</a>.
<p>(skipped: C++ framework and raycast sections)

<h2>Physics system</h2>

<p>The physics system will be used to store all the objects present in the scene.
<p>These objects are called rigidBodies (they keep their shape and mass constant during the simulation).

<p><code>// RigidBody (todo: use class?)

rigidBody = options => {
  return options;
}

rigidBody.update = deltaTime => {}
rigidBody.render = () => {}
rigidBody.applyForces = () => {}
rigidBody.solveConstraints = constraints => {}

// Physics system

physicsSystem = {

  bodies: [],       // Array of rigidBodies
  
  constraints: [],  // Array of constraints (OBBs for now)
  
  update: deltaTime => {
    for(var i of physicsSystem.bodies){
      i.applyForces();
    }
    for(i of physicsSystem.bodies){
      i.update(deltaTime);
    }
    for(i of physicsSystem.bodies){
      i.solveConstraints(physicsSystem.constraints);
    }
  },
  
  render: () => {
    for(var i of physicsSystem.bodies){
      i.render();
    }
    for(i of physicsSystem.constraints){
      i.render();
    }
  },
  
  addRigidBody: body => physicsSystem.bodies.push(body),
  
  addConstraint: constraint => physicsSystem.constraints.push(constraint),
  
  clear: () => {
    physicsSystem.bodies = [];
    physicsSystem.constraints = []
  }
}</code>

<h2>Integrating particles</h2>

<p>Integrating consists of guessing where an object will be in a given amount of time based on its current position and velocity, and the forces applied to it.
<p>Integrating the acceleration in respect to time will yield the object's updated velocity.
<p>Then, integrating the velocity in respect to time will yield the updated position.
<p>These are called Euler integrations and are based on Newton's Laws of Motion:
<p>1) An object's velocity doesn't change unless it is affected by an external force.
<p>2) An object's acceleration os proportional to the magnitude of the force acting on it, and inversely proportonal to its mass.
<p>3) Every action has an equal and opposite reaction.
<p><code class=f>F = MA // Force = Mass * Acceleration</code>
<p>At each frame of our simulation:
<p>- The time elapsed since last frame is measured (or hard-coded), commonly called deltaTime (Δt).
<p>- The new velocity of an object is its previous velocity plus acceleration forces applied for the duration of the elapsed time.
<p><code class=f>V<sub>new</sub> = V + AΔt</code>
<p>- The new position of an object is its previous position plus its velocity scaled over the elapsed time. 
<p><code class=f>P<sub>new</sub> = P + VΔt</code>
<p>Let's begin with particles (rigidBodies with no size), that are only affected by gravity.

<p><code>gravity = new DOMPoint(0,-1,0,0);
friction = 1;


particle = options => {
  options.position ??= new DOMPoint();
  options.oldPosition ??= new DOMPoint();
  options.forces ??= new DOMPoint(0,0,0,0);
  options.velocity ??= new DOMPoint(0,0,0,0);
  options.mass ??= 1;
  options.bounce ??= 1;
}</code>

<h2>Solving constraints</h2>

<h2>Verlet integration</h2>

<style>
body { font: 15px calibri }
h2 { margin: 30px 0 0 0; }
code { display: inline-block; background: #def; padding: 10px; margin: 10px 0; font: bold 14px/22px courier; white-space: pre; position: relative;}
.f { background: #fde; font-family: arial; }
code:before { content: "JS code"; color: #abc; position: absolute; top: -17px; left: 0px; font-size: 10px; }
code.f:before { content: "Formula"; color: #cab; }
p { padding: 0 0 0 10px }
code b.sqrt { border-top: 1px solid; }
</style>